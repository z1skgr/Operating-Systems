\hypertarget{kernel__cc_8c}{}\section{kernel\+\_\+cc.\+c File Reference}
\label{kernel__cc_8c}\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}


The implementation for concurrency control .  


{\ttfamily \#include $<$assert.\+h$>$}\\*
{\ttfamily \#include \char`\"{}kernel\+\_\+sched.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}kernel\+\_\+proc.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}kernel\+\_\+cc.\+h\char`\"{}}\\*
Include dependency graph for kernel\+\_\+cc.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{kernel__cc_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries M\+U\+T\+E\+X\+\_\+\+S\+P\+I\+NS}~1000\hypertarget{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}{}\label{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__syscalls_ga1140be44df71d39edaf6a7262fb763ca}{Mutex\+\_\+\+Lock} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Lock a mutex. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga0b98d0315d0931d0c28104c36dd559c9}{Mutex\+\_\+\+Unlock} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Unlock a mutex that you locked. \end{DoxyCompactList}\item 
static void {\bfseries remove\+\_\+from\+\_\+ring} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv, \+\_\+\+\_\+cv\+\_\+waiter $\ast$w)\hypertarget{kernel__cc_8c_abc2cf733db2b12d13a3f6e258f89dd2b}{}\label{kernel__cc_8c_abc2cf733db2b12d13a3f6e258f89dd2b}

\item 
static int {\bfseries cv\+\_\+wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause, \hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration} timeout)\hypertarget{kernel__cc_8c_a639afd8d38fd525e27bf8bb1fadf24ee}{}\label{kernel__cc_8c_a639afd8d38fd525e27bf8bb1fadf24ee}

\item 
static void {\bfseries cv\+\_\+signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)\hypertarget{kernel__cc_8c_a57708cb3ca29d1a575df0af638ca7d8d}{}\label{kernel__cc_8c_a57708cb3ca29d1a575df0af638ca7d8d}

\item 
int \hyperlink{group__syscalls_ga970dca2210b3f2ec8aedab7f542a9bf4}{Cond\+\_\+\+Wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
int \hyperlink{group__syscalls_ga4e955b769339be9ea6a0c1bd4151c48f}{Cond\+\_\+\+Timed\+Wait} (\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} $\ast$mutex, \hyperlink{structCondVar}{Cond\+Var} $\ast$cv, \hyperlink{group__syscalls_gaf412159e5cef839836a5e7b19ee75d1c}{timeout\+\_\+t} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga43f64f8be273d2fe77d7de5f4b81e22d}{Cond\+\_\+\+Signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{group__syscalls_ga8196aa2a48cad90742f254cc3b8fd351}{Cond\+\_\+\+Broadcast} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Notify all threads waiting at a condition variable. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption} (int preempt)
\begin{DoxyCompactList}\small\item\em Set the preemption status for the current thread. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}{get\+\_\+core\+\_\+preemption} ()
\begin{DoxyCompactList}\small\item\em Get the current preemption status. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}{kernel\+\_\+lock} ()\hypertarget{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}{}\label{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}

\begin{DoxyCompactList}\small\item\em Lock the kernel. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}{kernel\+\_\+unlock} ()\hypertarget{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}{}\label{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}

\begin{DoxyCompactList}\small\item\em Unlock the kernel. \end{DoxyCompactList}\item 
int \hyperlink{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}{kernel\+\_\+wait\+\_\+wchan} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause, const char $\ast$wchan\+\_\+name, \hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable using the kernel lock. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}{kernel\+\_\+signal} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a kernel condition to one waiter. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}{kernel\+\_\+broadcast} (\hyperlink{structCondVar}{Cond\+Var} $\ast$cv)\hypertarget{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}{}\label{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}

\begin{DoxyCompactList}\small\item\em Signal a kernel condition to all waiters. \end{DoxyCompactList}\item 
void \hyperlink{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}{kernel\+\_\+sleep} (\hyperlink{group__scheduler_ga6c969c169777f82c104cf73e501df70f}{Thread\+\_\+state} newstate, enum \hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE} cause)
\begin{DoxyCompactList}\small\item\em Put thread to sleep, unlocking the kernel. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex} \hyperlink{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}{kernel\+\_\+mutex} = \hyperlink{group__syscalls_ga96be0bfc33e7e113099c7546798bec99}{M\+U\+T\+E\+X\+\_\+\+I\+N\+IT}
\begin{DoxyCompactList}\small\item\em The kernel lock. \end{DoxyCompactList}\item 
static int {\bfseries kernel\+\_\+sem} = 1\hypertarget{kernel__cc_8c_a1c9aaa217ee98e133a7d199b5e0049f3}{}\label{kernel__cc_8c_a1c9aaa217ee98e133a7d199b5e0049f3}

\item 
static \hyperlink{structCondVar}{Cond\+Var} {\bfseries kernel\+\_\+sem\+\_\+cv} = \hyperlink{group__syscalls_ga6a7055a466bff255172e05f6ec82d792}{C\+O\+N\+D\+\_\+\+I\+N\+IT}\hypertarget{kernel__cc_8c_addaf45de2e9f92b9eb5ed68cc1017e6f}{}\label{kernel__cc_8c_addaf45de2e9f92b9eb5ed68cc1017e6f}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
The implementation for concurrency control . 

Locks for scheduler and device drivers. Because we support multiple cores, we need to avoid race conditions with an interrupt handler on the same core, and also to avoid race conditions between cores. 

\subsection{Function Documentation}
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!get\+\_\+core\+\_\+preemption@{get\+\_\+core\+\_\+preemption}}
\index{get\+\_\+core\+\_\+preemption@{get\+\_\+core\+\_\+preemption}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{get\+\_\+core\+\_\+preemption()}{get_core_preemption()}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+\_\+core\+\_\+preemption (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}{}\label{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}


Get the current preemption status. 

\begin{DoxyReturn}{Returns}
the current preemption status for this core, 0 means no preemption and 1 means preemption. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{kernel__cc_8h_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption} 
\end{DoxySeeAlso}


Definition at line 225 of file kernel\+\_\+cc.\+c.

\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+signal@{kernel\+\_\+signal}}
\index{kernel\+\_\+signal@{kernel\+\_\+signal}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{kernel\+\_\+signal(\+Cond\+Var $\ast$cv)}{kernel_signal(CondVar *cv)}}]{\setlength{\rightskip}{0pt plus 5cm}void kernel\+\_\+signal (
\begin{DoxyParamCaption}
\item[{{\bf Cond\+Var} $\ast$}]{cv}
\end{DoxyParamCaption}
)}\hypertarget{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}{}\label{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}


Signal a kernel condition to one waiter. 

This call must be made 

Definition at line 291 of file kernel\+\_\+cc.\+c.

\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+sleep@{kernel\+\_\+sleep}}
\index{kernel\+\_\+sleep@{kernel\+\_\+sleep}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{kernel\+\_\+sleep(\+Thread\+\_\+state newstate, enum S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+S\+E cause)}{kernel_sleep(Thread_state newstate, enum SCHED_CAUSE cause)}}]{\setlength{\rightskip}{0pt plus 5cm}void kernel\+\_\+sleep (
\begin{DoxyParamCaption}
\item[{{\bf Thread\+\_\+state}}]{state, }
\item[{enum {\bf S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}]{cause}
\end{DoxyParamCaption}
)}\hypertarget{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}{}\label{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}


Put thread to sleep, unlocking the kernel. 

System calls should call this function instead of {\ttfamily sleep\+\_\+releasing}, as the kernel lock is not a mutex. 

Definition at line 301 of file kernel\+\_\+cc.\+c.

\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+wait\+\_\+wchan@{kernel\+\_\+wait\+\_\+wchan}}
\index{kernel\+\_\+wait\+\_\+wchan@{kernel\+\_\+wait\+\_\+wchan}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{kernel\+\_\+wait\+\_\+wchan(\+Cond\+Var $\ast$cv, enum S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+S\+E cause, const char $\ast$wchan\+\_\+name, Timer\+Duration timeout)}{kernel_wait_wchan(CondVar *cv, enum SCHED_CAUSE cause, const char *wchan_name, TimerDuration timeout)}}]{\setlength{\rightskip}{0pt plus 5cm}int kernel\+\_\+wait\+\_\+wchan (
\begin{DoxyParamCaption}
\item[{{\bf Cond\+Var} $\ast$}]{cv, }
\item[{enum {\bf S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}]{cause, }
\item[{const char $\ast$}]{wchan, }
\item[{{\bf Timer\+Duration}}]{timeout}
\end{DoxyParamCaption}
)}\hypertarget{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}{}\label{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}


Wait on a condition variable using the kernel lock. 

\begin{DoxyReturn}{Returns}
1 if signalled, 0 if not 
\end{DoxyReturn}


Definition at line 272 of file kernel\+\_\+cc.\+c.

\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!set\+\_\+core\+\_\+preemption@{set\+\_\+core\+\_\+preemption}}
\index{set\+\_\+core\+\_\+preemption@{set\+\_\+core\+\_\+preemption}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{set\+\_\+core\+\_\+preemption(int preempt)}{set_core_preemption(int preempt)}}]{\setlength{\rightskip}{0pt plus 5cm}int set\+\_\+core\+\_\+preemption (
\begin{DoxyParamCaption}
\item[{int}]{preempt}
\end{DoxyParamCaption}
)}\hypertarget{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}{}\label{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}


Set the preemption status for the current thread. 

Depending on the value of the argument, this function will set preemption on or off. Preemption is disabled by disabling interrupts. This function is usually called via the convenience macros {\ttfamily preempt\+\_\+on} and {\ttfamily preempt\+\_\+off}. A typical non-\/preemptive section is declared as 
\begin{DoxyCode}
1 int preempt = preempt\_off;
2 ..
3     // do stuff without preemption 
4 ...
5 if(preempt) preempt\_on;
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em preempt} & the new preemption status \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the previous preemption status, where 0 means that preemption was previously off, and 1 means that it was on.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{kernel__cc_8h_af936bcf607a61848cfea21c119f30905}{preempt\+\_\+off} 

\hyperlink{kernel__cc_8h_ac8efed506a60c7c6f02514e878a4004b}{preempt\+\_\+on} 
\end{DoxySeeAlso}


Definition at line 209 of file kernel\+\_\+cc.\+c.



\subsection{Variable Documentation}
\index{kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}!kernel\+\_\+mutex@{kernel\+\_\+mutex}}
\index{kernel\+\_\+mutex@{kernel\+\_\+mutex}!kernel\+\_\+cc.\+c@{kernel\+\_\+cc.\+c}}
\subsubsection[{\texorpdfstring{kernel\+\_\+mutex}{kernel_mutex}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mutex} kernel\+\_\+mutex = {\bf M\+U\+T\+E\+X\+\_\+\+I\+N\+IT}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}{}\label{kernel__cc_8c_a57ffb2dcd44b56da47dc03b2f85d9480}


The kernel lock. 

Kernel locking is provided by a semaphore, implemented as a monitor. A semaphre for kernel locking has the advantage that 

Definition at line 246 of file kernel\+\_\+cc.\+c.

